"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@scure";
exports.ids = ["vendor-chunks/@scure"];
exports.modules = {

/***/ "(ssr)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUcsYUFBYSxnQkFBZ0I7QUFDckc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxTQUFTO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBLDhEQUE4RCxNQUFNLEtBQUssSUFBSSxZQUFZLHNCQUFzQjtBQUMvRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRyxPQUFPLEtBQUs7QUFDL0U7QUFDQTtBQUNBLGlFQUFpRSxLQUFLLE9BQU8sS0FBSztBQUNsRjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYztBQUN4RjtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLGdCQUFnQixNQUFNO0FBQzlFO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxHQUFHLDRCQUE0QixFQUFFLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7QUFDQSx3REFBd0QsWUFBWSxHQUFHLElBQUksa0JBQWtCLE1BQU07QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLGNBQWMsSUFBSTtBQUN6RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQjtBQUMzQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanM/YmQ0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzXG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3QgaWQgPSAoYSkgPT4gYTtcbiAgICAvLyBXcmFwIGNhbGwgaW4gY2xvc3VyZSBzbyBKSVQgY2FuIGlubGluZSBjYWxsc1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbLTFdLmVuY29kZShhcmdzWy0yXS5lbmNvZGUoWy4uLl0pKVxuICAgIGNvbnN0IGVuY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmVuY29kZSkucmVkdWNlUmlnaHQod3JhcCwgaWQpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWzBdLmRlY29kZShhcmdzWzFdLmRlY29kZSguLi4pKVxuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmRlY29kZSkucmVkdWNlKHdyYXAsIGlkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGludGVnZXIgcmFkaXggcmVwcmVzZW50YXRpb24gdG8gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhbHBoYWJldCBhbmQgYmFja1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhZCBzdHJpbmdzIGFycmF5IHNvIGl0IGhhcyBpbnRlZ2VyIG51bWJlciBvZiBiaXRzXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIC8vIGJhc2UgMSBpcyBpbXBvc3NpYmxlXG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gcm91bmRlZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocm91bmRlZCkgfHwgcm91bmRlZCAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3VuZGVkKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogSWYgYm90aCBiYXNlcyBhcmUgcG93ZXIgb2Ygc2FtZSBudW1iZXIgKGxpa2UgYDIqKjggPC0+IDIqKjY0YCksXG4gKiB0aGVyZSBpcyBhIGxpbmVhciBhbGdvcml0aG0uIEZvciBub3cgd2UgaGF2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgcG93ZXItb2YtdHdvIGJhc2VzIG9ubHkuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICAgIGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIGNvbnZlcnRSYWRpeCwgY29udmVydFJhZGl4MiwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyxcbn07XG4vLyBSRkMgNDY0OCBha2EgUkZDIDM1NDhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzIgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4cnAgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyB4bXIgdmVyIGlzIGRvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4vLyBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAvKiBAX19QVVJFX18gKi8gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgYmFzZTU4KTtcbi8vIGxlZ2FjeSBleHBvcnQsIGJhZCBuYW1lXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwcmVmaXgubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IGxvd2VyZWQubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbG93ZXJlZC5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShkYXRhKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@scure/bip32/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HARDENED_OFFSET: () => (/* binding */ HARDENED_OFFSET),\n/* harmony export */   HDKey: () => (/* binding */ HDKey)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n\n\nconst Point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint;\nconst base58check = (0,_scure_base__WEBPACK_IMPORTED_MODULE_1__.base58check)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\nfunction bytesToNumber(bytes) {\n    return BigInt(`0x${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.bytesToHex)(bytes)}`);\n}\nfunction numberToBytes(num) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nconst HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_4__.ripemd160)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(data));\nconst fromU32 = (data) => (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n    }\n    const buf = new Uint8Array(4);\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(buf).setUint32(0, n, false);\n    return buf;\n};\nclass HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__.sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string') {\n                throw new Error(`Invalid child index: ${c}`);\n            }\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(this.pubKey, data);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__.sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_8__.mod)(this.privKey + childTweak, _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.CURVE.n);\n                if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(hash, 32);\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(hash, 32);\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMwQztBQUNVO0FBQ047QUFDQTtBQUNlO0FBQ3NDO0FBQ3ZDO0FBQ1A7QUFDTTtBQUMzRCxjQUFjLDhEQUFJO0FBQ2xCLG9CQUFvQix3REFBYSxDQUFDLHdEQUFNO0FBQ3hDO0FBQ0EsdUJBQXVCLCtEQUFVLFFBQVE7QUFDekM7QUFDQTtBQUNBLFdBQVcsK0RBQVU7QUFDckI7QUFDQSxzQkFBc0IsZ0VBQVc7QUFDakM7QUFDQSwyQkFBMkI7QUFDcEI7QUFDUCwwQkFBMEIsa0VBQVMsQ0FBQyw0REFBTTtBQUMxQywwQkFBMEIsK0RBQVU7QUFDcEM7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQSxJQUFJLCtEQUFVO0FBQ2Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxnRUFBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBVztBQUNuQjtBQUNBLHdEQUF3RCxZQUFZLHNDQUFzQztBQUMxRztBQUNBLGtCQUFrQix3REFBSSxDQUFDLHdEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4REFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFJO0FBQzlCO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBVztBQUM5QjtBQUNBLGtCQUFrQix3REFBSSxDQUFDLHdEQUFNO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLDhEQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtRUFBRyw0QkFBNEIsOERBQUk7QUFDakUscUJBQXFCLDhEQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBVztBQUNuQixlQUFlLDhEQUFJO0FBQ25CO0FBQ0E7QUFDQSxRQUFRLDJEQUFXO0FBQ25CLFFBQVEsMkRBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFXO0FBQ25CO0FBQ0EsZUFBZSxnRUFBVztBQUMxQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9saWIvZXNtL2luZGV4LmpzPzViMzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJpcDMyIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF0cmljaW8gUGFsbGFkaW5vLCBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgcmlwZW1kMTYwIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGE1MTInO1xuaW1wb3J0IHsgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL19hc3NlcnQnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgY29uY2F0Qnl0ZXMsIGNyZWF0ZVZpZXcsIGhleFRvQnl0ZXMsIHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCB7IG1vZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG5pbXBvcnQgeyBiYXNlNThjaGVjayBhcyBiYXNlNThjaGVja2VyIH0gZnJvbSAnQHNjdXJlL2Jhc2UnO1xuY29uc3QgUG9pbnQgPSBzZWNwLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IGJhc2U1OGNoZWNrID0gYmFzZTU4Y2hlY2tlcihzaGEyNTYpO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIHJldHVybiBCaWdJbnQoYDB4JHtieXRlc1RvSGV4KGJ5dGVzKX1gKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXMobnVtKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKSk7XG59XG5jb25zdCBNQVNURVJfU0VDUkVUID0gdXRmOFRvQnl0ZXMoJ0JpdGNvaW4gc2VlZCcpO1xuLy8gQml0Y29pbiBoYXJkY29kZWQgYnkgZGVmYXVsdFxuY29uc3QgQklUQ09JTl9WRVJTSU9OUyA9IHsgcHJpdmF0ZTogMHgwNDg4YWRlNCwgcHVibGljOiAweDA0ODhiMjFlIH07XG5leHBvcnQgY29uc3QgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMDtcbmNvbnN0IGhhc2gxNjAgPSAoZGF0YSkgPT4gcmlwZW1kMTYwKHNoYTI1NihkYXRhKSk7XG5jb25zdCBmcm9tVTMyID0gKGRhdGEpID0+IGNyZWF0ZVZpZXcoZGF0YSkuZ2V0VWludDMyKDAsIGZhbHNlKTtcbmNvbnN0IHRvVTMyID0gKG4pID0+IHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwIHx8IG4gPiAyICoqIDMyIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyPSR7bn0uIFNob3VsZCBiZSBmcm9tIDAgdG8gMiAqKiAzMiAtIDFgKTtcbiAgICB9XG4gICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY3JlYXRlVmlldyhidWYpLnNldFVpbnQzMigwLCBuLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5leHBvcnQgY2xhc3MgSERLZXkge1xuICAgIGdldCBmaW5nZXJwcmludCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1Ykhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljS2V5IHNldCEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbVUzMih0aGlzLnB1Ykhhc2gpO1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHB1YktleUhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1Ykhhc2g7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2S2V5Qnl0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViS2V5IHx8IG51bGw7XG4gICAgfVxuICAgIGdldCBwcml2YXRlRXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIGNvbnN0IHByaXYgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcml2YXRlIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy5zZXJpYWxpemUodGhpcy52ZXJzaW9ucy5wcml2YXRlLCBjb25jYXRCeXRlcyhuZXcgVWludDhBcnJheShbMF0pLCBwcml2KSkpO1xuICAgIH1cbiAgICBnZXQgcHVibGljRXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy5zZXJpYWxpemUodGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHViS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWFzdGVyU2VlZChzZWVkLCB2ZXJzaW9ucyA9IEJJVENPSU5fVkVSU0lPTlMpIHtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMoc2VlZCk7XG4gICAgICAgIGlmICg4ICogc2VlZC5sZW5ndGggPCAxMjggfHwgOCAqIHNlZWQubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhES2V5OiB3cm9uZyBzZWVkIGxlbmd0aD0ke3NlZWQubGVuZ3RofS4gU2hvdWxkIGJlIGJldHdlZW4gMTI4IGFuZCA1MTIgYml0czsgMjU2IGJpdHMgaXMgYWR2aXNlZClgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBJID0gaG1hYyhzaGE1MTIsIE1BU1RFUl9TRUNSRVQsIHNlZWQpO1xuICAgICAgICByZXR1cm4gbmV3IEhES2V5KHtcbiAgICAgICAgICAgIHZlcnNpb25zLFxuICAgICAgICAgICAgY2hhaW5Db2RlOiBJLnNsaWNlKDMyKSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IEkuc2xpY2UoMCwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEtleShiYXNlNThrZXksIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICAvLyA9PiB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IGJhc2U1OGNoZWNrLmRlY29kZShiYXNlNThrZXkpO1xuICAgICAgICBjb25zdCBrZXlWaWV3ID0gY3JlYXRlVmlldyhrZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0ga2V5Vmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9ucyxcbiAgICAgICAgICAgIGRlcHRoOiBrZXlCdWZmZXJbNF0sXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDoga2V5Vmlldy5nZXRVaW50MzIoNSwgZmFsc2UpLFxuICAgICAgICAgICAgaW5kZXg6IGtleVZpZXcuZ2V0VWludDMyKDksIGZhbHNlKSxcbiAgICAgICAgICAgIGNoYWluQ29kZToga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSk7XG4gICAgICAgIGNvbnN0IGlzUHJpdiA9IGtleVswXSA9PT0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IHZlcnNpb25zW2lzUHJpdiA/ICdwcml2YXRlJyA6ICdwdWJsaWMnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpdikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHJpdmF0ZUtleToga2V5LnNsaWNlKDEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHVibGljS2V5OiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIEhES2V5LmZyb21FeHRlbmRlZEtleShqc29uLnhwcml2KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMDtcbiAgICAgICAgaWYgKCFvcHQgfHwgdHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9ucyA9IG9wdC52ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TO1xuICAgICAgICB0aGlzLmRlcHRoID0gb3B0LmRlcHRoIHx8IDA7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlID0gb3B0LmNoYWluQ29kZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG9wdC5pbmRleCB8fCAwO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gb3B0LnBhcmVudEZpbmdlcnByaW50IHx8IDA7XG4gICAgICAgIGlmICghdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IHplcm8gZGVwdGggd2l0aCBub24temVybyBpbmRleC9wYXJlbnQgZmluZ2VycHJpbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnB1YmxpY0tleSAmJiBvcHQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogcHVibGljS2V5IGFuZCBwcml2YXRlS2V5IGF0IHNhbWUgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShvcHQucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5wcml2YXRlS2V5ID09PSAnYmlnaW50JyA/IG9wdC5wcml2YXRlS2V5IDogYnl0ZXNUb051bWJlcihvcHQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IG51bWJlclRvQnl0ZXModGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXkob3B0LnByaXZhdGVLZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdC5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gUG9pbnQuZnJvbUhleChvcHQucHVibGljS2V5KS50b1Jhd0J5dGVzKHRydWUpOyAvLyBmb3JjZSBjb21wcmVzc2VkIHBvaW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiBubyBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ykhhc2ggPSBoYXNoMTYwKHRoaXMucHViS2V5KTtcbiAgICB9XG4gICAgZGVyaXZlKHBhdGgpIHtcbiAgICAgICAgaWYgKCEvXlttTV0nPy8udGVzdChwYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3Qgc3RhcnQgd2l0aCBcIm1cIiBvciBcIk1cIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlttTV0nPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5yZXBsYWNlKC9eW21NXSc/XFwvLywgJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAvXihcXGQrKSgnPykkLy5leGVjKGMpO1xuICAgICAgICAgICAgY29uc3QgbTEgPSBtICYmIG1bMV07XG4gICAgICAgICAgICBpZiAoIW0gfHwgbS5sZW5ndGggIT09IDMgfHwgdHlwZW9mIG0xICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGlsZCBpbmRleDogJHtjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlkeCA9ICttMTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaWR4KSB8fCBpZHggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYXJkZW5lZCBrZXlcbiAgICAgICAgICAgIGlmIChtWzJdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGlkeCArPSBIQVJERU5FRF9PRkZTRVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmRlcml2ZUNoaWxkKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBkZXJpdmVDaGlsZChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucHViS2V5IHx8ICF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgb3IgY2hhaW5Db2RlIHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdG9VMzIoaW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAvLyBIYXJkZW5lZFxuICAgICAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhcmRlbmVkIGNoaWxkOiAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICAgICAgICAgIGRhdGEgPSBjb25jYXRCeXRlcyhuZXcgVWludDhBcnJheShbMF0pLCBwcml2LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjaGlsZDogc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgICAgICAgICBkYXRhID0gY29uY2F0Qnl0ZXModGhpcy5wdWJLZXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBobWFjKHNoYTUxMiwgdGhpcy5jaGFpbkNvZGUsIGRhdGEpO1xuICAgICAgICBjb25zdCBjaGlsZFR3ZWFrID0gYnl0ZXNUb051bWJlcihJLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IEkuc2xpY2UoMzIpO1xuICAgICAgICBpZiAoIXNlY3AudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoY2hpbGRUd2VhaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHdlYWsgYmlnZ2VyIHRoYW4gY3VydmUgb3JkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uczogdGhpcy52ZXJzaW9ucyxcbiAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoICsgMSxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IG1vZCh0aGlzLnByaXZLZXkgKyBjaGlsZFR3ZWFrLCBzZWNwLkNVUlZFLm4pO1xuICAgICAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShhZGRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciB0aGUgcmVzdWx0ZWQgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQucHJpdmF0ZUtleSA9IGFkZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWQgPSBQb2ludC5mcm9tSGV4KHRoaXMucHViS2V5KS5hZGQoUG9pbnQuZnJvbVByaXZhdGVLZXkoY2hpbGRUd2VhaykpO1xuICAgICAgICAgICAgICAgIC8vIENyeXB0b2dyYXBoaWNhbGx5IGltcG9zc2libGU6IGhtYWMtc2hhNTEyIHByZWltYWdlIHdvdWxkIG5lZWQgdG8gYmUgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQuZXF1YWxzKFBvaW50LlpFUk8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR3ZWFrIHdhcyBlcXVhbCB0byBuZWdhdGl2ZSBQLCB3aGljaCBtYWRlIHRoZSByZXN1bHQga2V5IGludmFsaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LnB1YmxpY0tleSA9IGFkZGVkLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhES2V5KG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlQ2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaWduKGhhc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJpdmF0ZUtleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoaGFzaCwgMzIpO1xuICAgICAgICByZXR1cm4gc2VjcC5zaWduKGhhc2gsIHRoaXMucHJpdktleSkudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICB9XG4gICAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRCeXRlcyhoYXNoLCAzMik7XG4gICAgICAgIGFzc2VydEJ5dGVzKHNpZ25hdHVyZSwgNjQpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZyA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZywgaGFzaCwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICB3aXBlUHJpdmF0ZURhdGEoKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHJpdktleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5wcml2S2V5Qnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICAgICAgICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2ZXJzaW9uLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoa2V5LCAzMyk7XG4gICAgICAgIC8vIHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHRvVTMyKHZlcnNpb24pLCBuZXcgVWludDhBcnJheShbdGhpcy5kZXB0aF0pLCB0b1UzMih0aGlzLnBhcmVudEZpbmdlcnByaW50KSwgdG9VMzIodGhpcy5pbmRleCksIHRoaXMuY2hhaW5Db2RlLCBrZXkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/OGFmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/MTU4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsR0FBRyxFQUFDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/ZGJhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQzNCLGVBQWUsMk1BQUUsV0FBVywyTUFBRSxpQkFBaUIsME5BQWlCLEdBQUcsa0RBQVk7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz9mOThkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/NWRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLDBDQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxvREFBb0Q7QUFDcEQsc0RBQXNEO0FBQ3RELDREQUE0RDtBQUM1RCw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLDBEQUFlO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcz8yZTk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcbmNvbnN0IFJobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheShbNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOF0pO1xuY29uc3QgSWQgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IC8qIEBfX1BVUkVfXyAqLyBJZC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpO1xubGV0IGlkeEwgPSBbSWRdO1xubGV0IGlkeFIgPSBbUGldO1xuZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgZm9yIChsZXQgaiBvZiBbaWR4TCwgaWR4Ul0pXG4gICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvW2tdKSk7XG5jb25zdCBzaGlmdHMgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IG5ldyBVaW50OEFycmF5KGkpKTtcbmNvbnN0IHNoaWZ0c0wgPSAvKiBAX19QVVJFX18gKi8gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xuY29uc3QgS2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlLFxuXSk7XG5jb25zdCBLciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSgxNik7XG5leHBvcnQgY2xhc3MgUklQRU1EMTYwIGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRltpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbFtncm91cF0sIGhiciA9IEtyW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTFtncm91cF0sIHNyID0gc2hpZnRzUltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAocm90bChhbCArIGYoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSAocm90bChhciArIGYockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRltycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBCVUYuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKipcbiAqIFJJUEVNRC0xNjAgLSBhIGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gbXNnIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCByaXBlbWQxNjAgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaXBlbWQxNjAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/ZjEwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QztBQUNBO0FBQ0Esc0RBQXNELHFEQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMsd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxFQUFFLG1EQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQyxpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QyxtQ0FBbUMsMERBQWU7QUFDbEQsbUNBQW1DLDBEQUFlO0FBQ2xELCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/MGQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ1Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/NDg3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuLy8gT3RoZXIgbGlicmFyaWVzIHdvdWxkIHNpbGVudGx5IGNvcnJ1cHQgdGhlIGRhdGEgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcixcbi8vIHdoZW4gdGhleSBkb24ndCBzdXBwb3J0IGl0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKCFpc0J5dGVzKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n\n\n\n\n\n\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(entropy, 16, 20, 24, 28, 32);\n}\nfunction generateMnemonic(wordlist, strength = 128) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    const bitsLeft = 8 - entropy.length / 4;\n    return new Uint8Array([((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Worlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.alphabet(wordlist));\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDZ0I7QUFDYjtBQUNBO0FBQ0k7QUFDRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxrRUFBWTtBQUNoQjtBQUNPO0FBQ1AsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRTtBQUMvRCxLQUFLO0FBQ0wsV0FBVyw4Q0FBUyxPQUFPLDhDQUFTLDRCQUE0Qiw4Q0FBUyxtQkFBbUIsOENBQVM7QUFDckc7QUFDTztBQUNQLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUNqRDtBQUNQLFdBQVcsaUVBQVcsQ0FBQyx3REFBTSxnREFBZ0Qsb0JBQW9CO0FBQ2pHO0FBQ087QUFDUCxXQUFXLDREQUFNLENBQUMsd0RBQU0sZ0RBQWdELG9CQUFvQjtBQUM1RjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvZXNtL2luZGV4LmpzP2I5ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdAbm9ibGUvaGFzaGVzL19hc3NlcnQnO1xuaW1wb3J0IHsgcGJrZGYyLCBwYmtkZjJBc3luYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcGJrZGYyJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB1dGlscyBhcyBiYXNlVXRpbHMgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG5jb25zdCBpc0phcGFuZXNlID0gKHdvcmRsaXN0KSA9PiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5Myc7XG5mdW5jdGlvbiBuZmtkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoJ05GS0QnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICBjb25zdCBub3JtID0gbmZrZChzdHIpO1xuICAgIGNvbnN0IHdvcmRzID0gbm9ybS5zcGxpdCgnICcpO1xuICAgIGlmICghWzEyLCAxNSwgMTgsIDIxLCAyNF0uaW5jbHVkZXMod29yZHMubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1uZW1vbmljJyk7XG4gICAgcmV0dXJuIHsgbmZrZDogbm9ybSwgd29yZHMgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudHJvcHkoZW50cm9weSkge1xuICAgIGFzc2VydC5ieXRlcyhlbnRyb3B5LCAxNiwgMjAsIDI0LCAyOCwgMzIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QsIHN0cmVuZ3RoID0gMTI4KSB7XG4gICAgYXNzZXJ0Lm51bWJlcihzdHJlbmd0aCk7XG4gICAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDAgfHwgc3RyZW5ndGggPiAyNTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZW50cm9weScpO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhyYW5kb21CeXRlcyhzdHJlbmd0aCAvIDgpLCB3b3JkbGlzdCk7XG59XG5jb25zdCBjYWxjQ2hlY2tzdW0gPSAoZW50cm9weSkgPT4ge1xuICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhzaGEyNTYoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmxpc3Q6IGV4cGVjdGVkIGFycmF5IG9mIDIwNDggc3RyaW5ncycpO1xuICAgIHdvcmRsaXN0LmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29yZGxpc3Q6IG5vbi1zdHJpbmcgZWxlbWVudDogJHtpfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlVXRpbHMuY2hhaW4oYmFzZVV0aWxzLmNoZWNrc3VtKDEsIGNhbGNDaGVja3N1bSksIGJhc2VVdGlscy5yYWRpeDIoMTEsIHRydWUpLCBiYXNlVXRpbHMuYWxwaGFiZXQod29yZGxpc3QpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhc3NlcnRFbnRyb3B5KGVudHJvcHkpO1xuICAgIHJldHVybiBlbnRyb3B5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgYXNzZXJ0RW50cm9weShlbnRyb3B5KTtcbiAgICBjb25zdCB3b3JkcyA9IGdldENvZGVyKHdvcmRsaXN0KS5lbmNvZGUoZW50cm9weSk7XG4gICAgcmV0dXJuIHdvcmRzLmpvaW4oaXNKYXBhbmVzZSh3b3JkbGlzdCkgPyAnXFx1MzAwMCcgOiAnICcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHNhbHQgPSAocGFzc3BocmFzZSkgPT4gbmZrZChgbW5lbW9uaWMke3Bhc3NwaHJhc2V9YCk7XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3NwaHJhc2UgPSAnJykge1xuICAgIHJldHVybiBwYmtkZjJBc3luYyhzaGE1MTIsIG5vcm1hbGl6ZShtbmVtb25pYykubmZrZCwgc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gcGJrZGYyKHNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MzdlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/NDI1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsR0FBRyxFQUFDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/ZGE5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQzNCLGVBQWUsMk1BQUUsV0FBVywyTUFBRSxpQkFBaUIsME5BQWlCLEdBQUcsa0RBQVk7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz9kMDM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/YzFmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEU7QUFDekM7QUFDc0M7QUFDdkU7QUFDQTtBQUNBLElBQUksZ0RBQVU7QUFDZCxpQkFBaUIsb0RBQVMsR0FBRywwQkFBMEI7QUFDdkQsWUFBWSxzQkFBc0I7QUFDbEMsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQixrREFBTztBQUM1QixpQkFBaUIsa0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUFJO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNPO0FBQ1AsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdDQUF3QztBQUNwRCxjQUFjO0FBQ2Q7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBUztBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vcGJrZGYyLmpzPzRkM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBudW1iZXIgYXMgYXNzZXJ0TnVtYmVyIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhtYWMgfSBmcm9tICcuL2htYWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgY2hlY2tPcHRzLCBhc3luY0xvb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2sgfSA9IG9wdHM7XG4gICAgYXNzZXJ0TnVtYmVyKGMpO1xuICAgIGFzc2VydE51bWJlcihka0xlbik7XG4gICAgYXNzZXJ0TnVtYmVyKGFzeW5jVGljayk7XG4gICAgaWYgKGMgPCAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BCS0RGMjogaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IHRvQnl0ZXMoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gdG9CeXRlcyhfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWMuY3JlYXRlKGhhc2gsIHBhc3N3b3JkKTtcbiAgICBjb25zdCBQUkZTYWx0ID0gUFJGLl9jbG9uZUludG8oKS51cGRhdGUoc2FsdCk7XG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xufVxuZnVuY3Rpb24gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpIHtcbiAgICBQUkYuZGVzdHJveSgpO1xuICAgIFBSRlNhbHQuZGVzdHJveSgpO1xuICAgIGlmIChwcmZXKVxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcbiAgICB1LmZpbGwoMCk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChsZXQgdWkgPSAxOyB1aSA8IGM7IHVpKyspIHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/MTJiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QztBQUNBO0FBQ0Esc0RBQXNELHFEQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMsd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxFQUFFLG1EQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQyxpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QyxtQ0FBbUMsMERBQWU7QUFDbEQsbUNBQW1DLDBEQUFlO0FBQ2xELCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/YjgzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ1Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/Yzg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuLy8gT3RoZXIgbGlicmFyaWVzIHdvdWxkIHNpbGVudGx5IGNvcnJ1cHQgdGhlIGRhdGEgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcixcbi8vIHdoZW4gdGhleSBkb24ndCBzdXBwb3J0IGl0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKCFpc0J5dGVzKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            const rounded = Math.floor(digitBase / to);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\n/**\n * Implemented with numbers, because BigInt is 5x slower\n * @__NO_SIDE_EFFECTS__\n */\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of numbers');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\nconst base16 = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = /* @__PURE__ */ chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = /* @__PURE__ */ chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64nopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = /* @__PURE__ */ chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = /* @__PURE__ */ genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = /* @__PURE__ */ genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = /* @__PURE__ */ genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n// Block encoding significantly reduces quadratic complexity of base58.\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = /* @__PURE__ */ (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n// legacy export, bad name\nconst base58check = createBase58check;\nconst BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        if (prefix.length === 0)\n            throw new TypeError(`Invalid prefix length ${prefix.length}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = /* @__PURE__ */ genBech32('bech32');\nconst bech32m = /* @__PURE__ */ genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = /* @__PURE__ */ chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUcsYUFBYSxnQkFBZ0I7QUFDckc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxTQUFTO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBLDhEQUE4RCxNQUFNLEtBQUssSUFBSSxZQUFZLHNCQUFzQjtBQUMvRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRyxPQUFPLEtBQUs7QUFDL0U7QUFDQTtBQUNBLGlFQUFpRSxLQUFLLE9BQU8sS0FBSztBQUNsRjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYztBQUN4RjtBQUNBLG1GQUFtRixhQUFhO0FBQ2hHO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBLDBDQUEwQyxjQUFjLGdCQUFnQixNQUFNO0FBQzlFO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxHQUFHLDRCQUE0QixFQUFFLElBQUk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7QUFDQSx3REFBd0QsWUFBWSxHQUFHLElBQUksa0JBQWtCLE1BQU07QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLGNBQWMsSUFBSTtBQUN6RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQjtBQUMzQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanM/NjkwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzXG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3QgaWQgPSAoYSkgPT4gYTtcbiAgICAvLyBXcmFwIGNhbGwgaW4gY2xvc3VyZSBzbyBKSVQgY2FuIGlubGluZSBjYWxsc1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgLy8gQ29uc3RydWN0IGNoYWluIG9mIGFyZ3NbLTFdLmVuY29kZShhcmdzWy0yXS5lbmNvZGUoWy4uLl0pKVxuICAgIGNvbnN0IGVuY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmVuY29kZSkucmVkdWNlUmlnaHQod3JhcCwgaWQpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWzBdLmRlY29kZShhcmdzWzFdLmRlY29kZSguLi4pKVxuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MubWFwKCh4KSA9PiB4LmRlY29kZSkucmVkdWNlKHdyYXAsIGlkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuLyoqXG4gKiBFbmNvZGVzIGludGVnZXIgcmFkaXggcmVwcmVzZW50YXRpb24gdG8gYXJyYXkgb2Ygc3RyaW5ncyB1c2luZyBhbHBoYWJldCBhbmQgYmFja1xuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhZCBzdHJpbmdzIGFycmF5IHNvIGl0IGhhcyBpbnRlZ2VyIG51bWJlciBvZiBiaXRzXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG4vKipcbiAqIFNsb3c6IE8obl4yKSB0aW1lIGNvbXBsZXhpdHlcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIC8vIGJhc2UgMSBpcyBpbXBvc3NpYmxlXG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gcm91bmRlZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocm91bmRlZCkgfHwgcm91bmRlZCAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyb3VuZGVkKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qQF9fTk9fU0lERV9FRkZFQ1RTX18gKi8gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG4vKipcbiAqIEltcGxlbWVudGVkIHdpdGggbnVtYmVycywgYmVjYXVzZSBCaWdJbnQgaXMgNXggc2xvd2VyXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7IC8vIGNsZWFuIGNhcnJ5LCBvdGhlcndpc2UgaXQgd2lsbCBjYXVzZSBvdmVyZmxvd1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogSWYgYm90aCBiYXNlcyBhcmUgcG93ZXIgb2Ygc2FtZSBudW1iZXIgKGxpa2UgYDIqKjggPC0+IDIqKjY0YCksXG4gKiB0aGVyZSBpcyBhIGxpbmVhciBhbGdvcml0aG0uIEZvciBub3cgd2UgaGF2ZSBpbXBsZW1lbnRhdGlvbiBmb3IgcG93ZXItb2YtdHdvIGJhc2VzIG9ubHkuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICAgIGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIGNvbnZlcnRSYWRpeCwgY29udmVydFJhZGl4MiwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyxcbn07XG4vLyBSRkMgNDY0OCBha2EgUkZDIDM1NDhcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzIgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NG5vcGFkID0gLyogQF9fUFVSRV9fICovIGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmxub3BhZCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIGpvaW4oJycpKTtcbi8vIGJhc2U1OCBjb2RlXG4vLyAtLS0tLS0tLS0tLVxuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gLyogQF9fUFVSRV9fICovIGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IC8qIEBfX1BVUkVfXyAqLyBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydCBjb25zdCBiYXNlNTh4cnAgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG4vLyB4bXIgdmVyIGlzIGRvbmUgaW4gOC1ieXRlIGJsb2NrcyAod2hpY2ggZXF1YWxzIDExIGNoYXJzIGluIGRlY29kaW5nKS4gTGFzdCAobm9uLWZ1bGwpIGJsb2NrIHBhZGRlZCB3aXRoICcxJyB0byBzaXplIGluIFhNUl9CTE9DS19MRU4uXG4vLyBCbG9jayBlbmNvZGluZyBzaWduaWZpY2FudGx5IHJlZHVjZXMgcXVhZHJhdGljIGNvbXBsZXhpdHkgb2YgYmFzZTU4LlxuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAvKiBAX19QVVJFX18gKi8gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgYmFzZTU4KTtcbi8vIGxlZ2FjeSBleHBvcnQsIGJhZCBuYW1lXG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSBjcmVhdGVCYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSAvKiBAX19QVVJFX18gKi8gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHByZWZpeCBsZW5ndGggJHtwcmVmaXgubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShsb3dlcmVkLCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICByZXR1cm4gYCR7bG93ZXJlZH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtzdW19YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgLy8gZG9uJ3QgYWxsb3cgbWl4ZWQgY2FzZVxuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IGxvd2VyZWQubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGxvd2VyZWQuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbG93ZXJlZC5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShkYXRhKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghZGF0YS5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSAvKiBAX19QVVJFX18gKi8gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydCBjb25zdCBiZWNoMzJtID0gLyogQF9fUFVSRV9fICovIGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IC8qIEBfX1BVUkVfXyAqLyBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSAnSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6IHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtcic7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCFpc0J5dGVzKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZzsgLy8gYXMgaW4gcHl0aG9uLCBidXQgZm9yIGJ5dGVzIG9ubHlcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/base/lib/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/lib/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@scure/bip32/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HARDENED_OFFSET: () => (/* binding */ HARDENED_OFFSET),\n/* harmony export */   HDKey: () => (/* binding */ HDKey)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(rsc)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(rsc)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @scure/base */ \"(rsc)/./node_modules/@scure/base/lib/esm/index.js\");\n/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n\n\nconst Point = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.ProjectivePoint;\nconst base58check = (0,_scure_base__WEBPACK_IMPORTED_MODULE_1__.base58check)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\nfunction bytesToNumber(bytes) {\n    return BigInt(`0x${(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.bytesToHex)(bytes)}`);\n}\nfunction numberToBytes(num) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.hexToBytes)(num.toString(16).padStart(64, '0'));\n}\nconst MASTER_SECRET = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)('Bitcoin seed');\n// Bitcoin hardcoded by default\nconst BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };\nconst HARDENED_OFFSET = 0x80000000;\nconst hash160 = (data) => (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_4__.ripemd160)((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(data));\nconst fromU32 = (data) => (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(data).getUint32(0, false);\nconst toU32 = (n) => {\n    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {\n        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);\n    }\n    const buf = new Uint8Array(4);\n    (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(buf).setUint32(0, n, false);\n    return buf;\n};\nclass HDKey {\n    get fingerprint() {\n        if (!this.pubHash) {\n            throw new Error('No publicKey set!');\n        }\n        return fromU32(this.pubHash);\n    }\n    get identifier() {\n        return this.pubHash;\n    }\n    get pubKeyHash() {\n        return this.pubHash;\n    }\n    get privateKey() {\n        return this.privKeyBytes || null;\n    }\n    get publicKey() {\n        return this.pubKey || null;\n    }\n    get privateExtendedKey() {\n        const priv = this.privateKey;\n        if (!priv) {\n            throw new Error('No private key');\n        }\n        return base58check.encode(this.serialize(this.versions.private, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(new Uint8Array([0]), priv)));\n    }\n    get publicExtendedKey() {\n        if (!this.pubKey) {\n            throw new Error('No public key');\n        }\n        return base58check.encode(this.serialize(this.versions.public, this.pubKey));\n    }\n    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(seed);\n        if (8 * seed.length < 128 || 8 * seed.length > 512) {\n            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__.sha512, MASTER_SECRET, seed);\n        return new HDKey({\n            versions,\n            chainCode: I.slice(32),\n            privateKey: I.slice(0, 32),\n        });\n    }\n    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {\n        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        const keyBuffer = base58check.decode(base58key);\n        const keyView = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.createView)(keyBuffer);\n        const version = keyView.getUint32(0, false);\n        const opt = {\n            versions,\n            depth: keyBuffer[4],\n            parentFingerprint: keyView.getUint32(5, false),\n            index: keyView.getUint32(9, false),\n            chainCode: keyBuffer.slice(13, 45),\n        };\n        const key = keyBuffer.slice(45);\n        const isPriv = key[0] === 0;\n        if (version !== versions[isPriv ? 'private' : 'public']) {\n            throw new Error('Version mismatch');\n        }\n        if (isPriv) {\n            return new HDKey({ ...opt, privateKey: key.slice(1) });\n        }\n        else {\n            return new HDKey({ ...opt, publicKey: key });\n        }\n    }\n    static fromJSON(json) {\n        return HDKey.fromExtendedKey(json.xpriv);\n    }\n    constructor(opt) {\n        this.depth = 0;\n        this.index = 0;\n        this.chainCode = null;\n        this.parentFingerprint = 0;\n        if (!opt || typeof opt !== 'object') {\n            throw new Error('HDKey.constructor must not be called directly');\n        }\n        this.versions = opt.versions || BITCOIN_VERSIONS;\n        this.depth = opt.depth || 0;\n        this.chainCode = opt.chainCode;\n        this.index = opt.index || 0;\n        this.parentFingerprint = opt.parentFingerprint || 0;\n        if (!this.depth) {\n            if (this.parentFingerprint || this.index) {\n                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');\n            }\n        }\n        if (opt.publicKey && opt.privateKey) {\n            throw new Error('HDKey: publicKey and privateKey at same time.');\n        }\n        if (opt.privateKey) {\n            if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {\n                throw new Error('Invalid private key');\n            }\n            this.privKey =\n                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);\n            this.privKeyBytes = numberToBytes(this.privKey);\n            this.pubKey = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.getPublicKey(opt.privateKey, true);\n        }\n        else if (opt.publicKey) {\n            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point\n        }\n        else {\n            throw new Error('HDKey: no public or private key provided');\n        }\n        this.pubHash = hash160(this.pubKey);\n    }\n    derive(path) {\n        if (!/^[mM]'?/.test(path)) {\n            throw new Error('Path must start with \"m\" or \"M\"');\n        }\n        if (/^[mM]'?$/.test(path)) {\n            return this;\n        }\n        const parts = path.replace(/^[mM]'?\\//, '').split('/');\n        // tslint:disable-next-line\n        let child = this;\n        for (const c of parts) {\n            const m = /^(\\d+)('?)$/.exec(c);\n            const m1 = m && m[1];\n            if (!m || m.length !== 3 || typeof m1 !== 'string') {\n                throw new Error(`Invalid child index: ${c}`);\n            }\n            let idx = +m1;\n            if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {\n                throw new Error('Invalid index');\n            }\n            // hardened key\n            if (m[2] === \"'\") {\n                idx += HARDENED_OFFSET;\n            }\n            child = child.deriveChild(idx);\n        }\n        return child;\n    }\n    deriveChild(index) {\n        if (!this.pubKey || !this.chainCode) {\n            throw new Error('No publicKey or chainCode set');\n        }\n        let data = toU32(index);\n        if (index >= HARDENED_OFFSET) {\n            // Hardened\n            const priv = this.privateKey;\n            if (!priv) {\n                throw new Error('Could not derive hardened child key');\n            }\n            // Hardened child: 0x00 || ser256(kpar) || ser32(index)\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(new Uint8Array([0]), priv, data);\n        }\n        else {\n            // Normal child: serP(point(kpar)) || ser32(index)\n            data = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(this.pubKey, data);\n        }\n        const I = (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_7__.sha512, this.chainCode, data);\n        const childTweak = bytesToNumber(I.slice(0, 32));\n        const chainCode = I.slice(32);\n        if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(childTweak)) {\n            throw new Error('Tweak bigger than curve order');\n        }\n        const opt = {\n            versions: this.versions,\n            chainCode,\n            depth: this.depth + 1,\n            parentFingerprint: this.fingerprint,\n            index,\n        };\n        try {\n            // Private parent key -> private child key\n            if (this.privateKey) {\n                const added = (0,_noble_curves_abstract_modular__WEBPACK_IMPORTED_MODULE_8__.mod)(this.privKey + childTweak, _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.CURVE.n);\n                if (!_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.utils.isValidPrivateKey(added)) {\n                    throw new Error('The tweak was out of range or the resulted private key is invalid');\n                }\n                opt.privateKey = added;\n            }\n            else {\n                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));\n                // Cryptographically impossible: hmac-sha512 preimage would need to be found\n                if (added.equals(Point.ZERO)) {\n                    throw new Error('The tweak was equal to negative P, which made the result key invalid');\n                }\n                opt.publicKey = added.toRawBytes(true);\n            }\n            return new HDKey(opt);\n        }\n        catch (err) {\n            return this.deriveChild(index + 1);\n        }\n    }\n    sign(hash) {\n        if (!this.privateKey) {\n            throw new Error('No privateKey set!');\n        }\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(hash, 32);\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.sign(hash, this.privKey).toCompactRawBytes();\n    }\n    verify(hash, signature) {\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(hash, 32);\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(signature, 64);\n        if (!this.publicKey) {\n            throw new Error('No publicKey set!');\n        }\n        let sig;\n        try {\n            sig = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.Signature.fromCompact(signature);\n        }\n        catch (error) {\n            return false;\n        }\n        return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_0__.secp256k1.verify(sig, hash, this.publicKey);\n    }\n    wipePrivateData() {\n        this.privKey = undefined;\n        if (this.privKeyBytes) {\n            this.privKeyBytes.fill(0);\n            this.privKeyBytes = undefined;\n        }\n        return this;\n    }\n    toJSON() {\n        return {\n            xpriv: this.privateExtendedKey,\n            xpub: this.publicExtendedKey,\n        };\n    }\n    serialize(version, key) {\n        if (!this.chainCode) {\n            throw new Error('No chainCode set');\n        }\n        (0,_noble_hashes_assert__WEBPACK_IMPORTED_MODULE_5__.bytes)(key, 33);\n        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)\n        return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMwQztBQUNVO0FBQ047QUFDQTtBQUNlO0FBQ3NDO0FBQ3ZDO0FBQ1A7QUFDTTtBQUMzRCxjQUFjLDhEQUFJO0FBQ2xCLG9CQUFvQix3REFBYSxDQUFDLHdEQUFNO0FBQ3hDO0FBQ0EsdUJBQXVCLCtEQUFVLFFBQVE7QUFDekM7QUFDQTtBQUNBLFdBQVcsK0RBQVU7QUFDckI7QUFDQSxzQkFBc0IsZ0VBQVc7QUFDakM7QUFDQSwyQkFBMkI7QUFDcEI7QUFDUCwwQkFBMEIsa0VBQVMsQ0FBQyw0REFBTTtBQUMxQywwQkFBMEIsK0RBQVU7QUFDcEM7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQSxJQUFJLCtEQUFVO0FBQ2Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxnRUFBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBVztBQUNuQjtBQUNBLHdEQUF3RCxZQUFZLHNDQUFzQztBQUMxRztBQUNBLGtCQUFrQix3REFBSSxDQUFDLHdEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0NBQWtDO0FBQ2pFO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4REFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhEQUFJO0FBQzlCO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdFQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBVztBQUM5QjtBQUNBLGtCQUFrQix3REFBSSxDQUFDLHdEQUFNO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLDhEQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtRUFBRyw0QkFBNEIsOERBQUk7QUFDakUscUJBQXFCLDhEQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBVztBQUNuQixlQUFlLDhEQUFJO0FBQ25CO0FBQ0E7QUFDQSxRQUFRLDJEQUFXO0FBQ25CLFFBQVEsMkRBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4REFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJEQUFXO0FBQ25CO0FBQ0EsZUFBZSxnRUFBVztBQUMxQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9saWIvZXNtL2luZGV4LmpzPzg1ODMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJpcDMyIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF0cmljaW8gUGFsbGFkaW5vLCBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgcmlwZW1kMTYwIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAnO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGE1MTInO1xuaW1wb3J0IHsgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL19hc3NlcnQnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgY29uY2F0Qnl0ZXMsIGNyZWF0ZVZpZXcsIGhleFRvQnl0ZXMsIHV0ZjhUb0J5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCB7IG1vZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG5pbXBvcnQgeyBiYXNlNThjaGVjayBhcyBiYXNlNThjaGVja2VyIH0gZnJvbSAnQHNjdXJlL2Jhc2UnO1xuY29uc3QgUG9pbnQgPSBzZWNwLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IGJhc2U1OGNoZWNrID0gYmFzZTU4Y2hlY2tlcihzaGEyNTYpO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlcihieXRlcykge1xuICAgIHJldHVybiBCaWdJbnQoYDB4JHtieXRlc1RvSGV4KGJ5dGVzKX1gKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXMobnVtKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKSk7XG59XG5jb25zdCBNQVNURVJfU0VDUkVUID0gdXRmOFRvQnl0ZXMoJ0JpdGNvaW4gc2VlZCcpO1xuLy8gQml0Y29pbiBoYXJkY29kZWQgYnkgZGVmYXVsdFxuY29uc3QgQklUQ09JTl9WRVJTSU9OUyA9IHsgcHJpdmF0ZTogMHgwNDg4YWRlNCwgcHVibGljOiAweDA0ODhiMjFlIH07XG5leHBvcnQgY29uc3QgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMDtcbmNvbnN0IGhhc2gxNjAgPSAoZGF0YSkgPT4gcmlwZW1kMTYwKHNoYTI1NihkYXRhKSk7XG5jb25zdCBmcm9tVTMyID0gKGRhdGEpID0+IGNyZWF0ZVZpZXcoZGF0YSkuZ2V0VWludDMyKDAsIGZhbHNlKTtcbmNvbnN0IHRvVTMyID0gKG4pID0+IHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwIHx8IG4gPiAyICoqIDMyIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyPSR7bn0uIFNob3VsZCBiZSBmcm9tIDAgdG8gMiAqKiAzMiAtIDFgKTtcbiAgICB9XG4gICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY3JlYXRlVmlldyhidWYpLnNldFVpbnQzMigwLCBuLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5leHBvcnQgY2xhc3MgSERLZXkge1xuICAgIGdldCBmaW5nZXJwcmludCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1Ykhhc2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljS2V5IHNldCEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvbVUzMih0aGlzLnB1Ykhhc2gpO1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHB1YktleUhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB1Ykhhc2g7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2S2V5Qnl0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViS2V5IHx8IG51bGw7XG4gICAgfVxuICAgIGdldCBwcml2YXRlRXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIGNvbnN0IHByaXYgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcml2YXRlIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy5zZXJpYWxpemUodGhpcy52ZXJzaW9ucy5wcml2YXRlLCBjb25jYXRCeXRlcyhuZXcgVWludDhBcnJheShbMF0pLCBwcml2KSkpO1xuICAgIH1cbiAgICBnZXQgcHVibGljRXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5wdWJLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHVibGljIGtleScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNThjaGVjay5lbmNvZGUodGhpcy5zZXJpYWxpemUodGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHViS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTWFzdGVyU2VlZChzZWVkLCB2ZXJzaW9ucyA9IEJJVENPSU5fVkVSU0lPTlMpIHtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMoc2VlZCk7XG4gICAgICAgIGlmICg4ICogc2VlZC5sZW5ndGggPCAxMjggfHwgOCAqIHNlZWQubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhES2V5OiB3cm9uZyBzZWVkIGxlbmd0aD0ke3NlZWQubGVuZ3RofS4gU2hvdWxkIGJlIGJldHdlZW4gMTI4IGFuZCA1MTIgYml0czsgMjU2IGJpdHMgaXMgYWR2aXNlZClgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBJID0gaG1hYyhzaGE1MTIsIE1BU1RFUl9TRUNSRVQsIHNlZWQpO1xuICAgICAgICByZXR1cm4gbmV3IEhES2V5KHtcbiAgICAgICAgICAgIHZlcnNpb25zLFxuICAgICAgICAgICAgY2hhaW5Db2RlOiBJLnNsaWNlKDMyKSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IEkuc2xpY2UoMCwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEtleShiYXNlNThrZXksIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICAvLyA9PiB2ZXJzaW9uKDQpIHx8IGRlcHRoKDEpIHx8IGZpbmdlcnByaW50KDQpIHx8IGluZGV4KDQpIHx8IGNoYWluKDMyKSB8fCBrZXkoMzMpXG4gICAgICAgIGNvbnN0IGtleUJ1ZmZlciA9IGJhc2U1OGNoZWNrLmRlY29kZShiYXNlNThrZXkpO1xuICAgICAgICBjb25zdCBrZXlWaWV3ID0gY3JlYXRlVmlldyhrZXlCdWZmZXIpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0ga2V5Vmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9ucyxcbiAgICAgICAgICAgIGRlcHRoOiBrZXlCdWZmZXJbNF0sXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDoga2V5Vmlldy5nZXRVaW50MzIoNSwgZmFsc2UpLFxuICAgICAgICAgICAgaW5kZXg6IGtleVZpZXcuZ2V0VWludDMyKDksIGZhbHNlKSxcbiAgICAgICAgICAgIGNoYWluQ29kZToga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSk7XG4gICAgICAgIGNvbnN0IGlzUHJpdiA9IGtleVswXSA9PT0gMDtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IHZlcnNpb25zW2lzUHJpdiA/ICdwcml2YXRlJyA6ICdwdWJsaWMnXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJzaW9uIG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJpdikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHJpdmF0ZUtleToga2V5LnNsaWNlKDEpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleSh7IC4uLm9wdCwgcHVibGljS2V5OiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIEhES2V5LmZyb21FeHRlbmRlZEtleShqc29uLnhwcml2KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMDtcbiAgICAgICAgaWYgKCFvcHQgfHwgdHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9ucyA9IG9wdC52ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TO1xuICAgICAgICB0aGlzLmRlcHRoID0gb3B0LmRlcHRoIHx8IDA7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlID0gb3B0LmNoYWluQ29kZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG9wdC5pbmRleCB8fCAwO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gb3B0LnBhcmVudEZpbmdlcnByaW50IHx8IDA7XG4gICAgICAgIGlmICghdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IHplcm8gZGVwdGggd2l0aCBub24temVybyBpbmRleC9wYXJlbnQgZmluZ2VycHJpbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnB1YmxpY0tleSAmJiBvcHQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogcHVibGljS2V5IGFuZCBwcml2YXRlS2V5IGF0IHNhbWUgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShvcHQucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5wcml2YXRlS2V5ID09PSAnYmlnaW50JyA/IG9wdC5wcml2YXRlS2V5IDogYnl0ZXNUb051bWJlcihvcHQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IG51bWJlclRvQnl0ZXModGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXkob3B0LnByaXZhdGVLZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdC5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gUG9pbnQuZnJvbUhleChvcHQucHVibGljS2V5KS50b1Jhd0J5dGVzKHRydWUpOyAvLyBmb3JjZSBjb21wcmVzc2VkIHBvaW50XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiBubyBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ykhhc2ggPSBoYXNoMTYwKHRoaXMucHViS2V5KTtcbiAgICB9XG4gICAgZGVyaXZlKHBhdGgpIHtcbiAgICAgICAgaWYgKCEvXlttTV0nPy8udGVzdChwYXRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3Qgc3RhcnQgd2l0aCBcIm1cIiBvciBcIk1cIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlttTV0nPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aC5yZXBsYWNlKC9eW21NXSc/XFwvLywgJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAvXihcXGQrKSgnPykkLy5leGVjKGMpO1xuICAgICAgICAgICAgY29uc3QgbTEgPSBtICYmIG1bMV07XG4gICAgICAgICAgICBpZiAoIW0gfHwgbS5sZW5ndGggIT09IDMgfHwgdHlwZW9mIG0xICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGlsZCBpbmRleDogJHtjfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGlkeCA9ICttMTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaWR4KSB8fCBpZHggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYXJkZW5lZCBrZXlcbiAgICAgICAgICAgIGlmIChtWzJdID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGlkeCArPSBIQVJERU5FRF9PRkZTRVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmRlcml2ZUNoaWxkKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBkZXJpdmVDaGlsZChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucHViS2V5IHx8ICF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgb3IgY2hhaW5Db2RlIHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdG9VMzIoaW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXggPj0gSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAvLyBIYXJkZW5lZFxuICAgICAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgICAgIGlmICghcHJpdikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhcmRlbmVkIGNoaWxkOiAweDAwIHx8IHNlcjI1NihrcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICAgICAgICAgIGRhdGEgPSBjb25jYXRCeXRlcyhuZXcgVWludDhBcnJheShbMF0pLCBwcml2LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbCBjaGlsZDogc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgICAgICAgICBkYXRhID0gY29uY2F0Qnl0ZXModGhpcy5wdWJLZXksIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBobWFjKHNoYTUxMiwgdGhpcy5jaGFpbkNvZGUsIGRhdGEpO1xuICAgICAgICBjb25zdCBjaGlsZFR3ZWFrID0gYnl0ZXNUb051bWJlcihJLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IEkuc2xpY2UoMzIpO1xuICAgICAgICBpZiAoIXNlY3AudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoY2hpbGRUd2VhaykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHdlYWsgYmlnZ2VyIHRoYW4gY3VydmUgb3JkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSB7XG4gICAgICAgICAgICB2ZXJzaW9uczogdGhpcy52ZXJzaW9ucyxcbiAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoICsgMSxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IG1vZCh0aGlzLnByaXZLZXkgKyBjaGlsZFR3ZWFrLCBzZWNwLkNVUlZFLm4pO1xuICAgICAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShhZGRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciB0aGUgcmVzdWx0ZWQgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQucHJpdmF0ZUtleSA9IGFkZGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWQgPSBQb2ludC5mcm9tSGV4KHRoaXMucHViS2V5KS5hZGQoUG9pbnQuZnJvbVByaXZhdGVLZXkoY2hpbGRUd2VhaykpO1xuICAgICAgICAgICAgICAgIC8vIENyeXB0b2dyYXBoaWNhbGx5IGltcG9zc2libGU6IGhtYWMtc2hhNTEyIHByZWltYWdlIHdvdWxkIG5lZWQgdG8gYmUgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQuZXF1YWxzKFBvaW50LlpFUk8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHR3ZWFrIHdhcyBlcXVhbCB0byBuZWdhdGl2ZSBQLCB3aGljaCBtYWRlIHRoZSByZXN1bHQga2V5IGludmFsaWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LnB1YmxpY0tleSA9IGFkZGVkLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhES2V5KG9wdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlQ2hpbGQoaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaWduKGhhc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcHJpdmF0ZUtleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoaGFzaCwgMzIpO1xuICAgICAgICByZXR1cm4gc2VjcC5zaWduKGhhc2gsIHRoaXMucHJpdktleSkudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICB9XG4gICAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgICAgICBhc3NlcnRCeXRlcyhoYXNoLCAzMik7XG4gICAgICAgIGFzc2VydEJ5dGVzKHNpZ25hdHVyZSwgNjQpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZyA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZywgaGFzaCwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICB3aXBlUHJpdmF0ZURhdGEoKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHJpdktleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5wcml2S2V5Qnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICAgICAgICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2ZXJzaW9uLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0Qnl0ZXMoa2V5LCAzMyk7XG4gICAgICAgIC8vIHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHRvVTMyKHZlcnNpb24pLCBuZXcgVWludDhBcnJheShbdGhpcy5kZXB0aF0pLCB0b1UzMih0aGlzLnBhcmVudEZpbmdlcnByaW50KSwgdG9VMzIodGhpcy5pbmRleCksIHRoaXMuY2hhaW5Db2RlLCBrZXkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/lib/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/MzgyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/MTUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsR0FBRyxFQUFDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/MGE2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQzNCLGVBQWUsMk1BQUUsV0FBVywyTUFBRSxpQkFBaUIsME5BQWlCLEdBQUcsa0RBQVk7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz85YWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/NDE1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\nconst Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);\nconst Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);\nconst Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);\nlet idxL = [Id];\nlet idxR = [Pi];\nfor (let i = 0; i < 4; i++)\n    for (let j of [idxL, idxR])\n        j.push(j[i].map((k) => Rho[k]));\nconst shifts = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => new Uint8Array(i));\nconst shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));\nconst Kl = /* @__PURE__ */ new Uint32Array([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr = /* @__PURE__ */ new Uint32Array([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));\n// It's called f() in spec.\nfunction f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    else if (group === 1)\n        return (x & y) | (~x & z);\n    else if (group === 2)\n        return (x | ~y) ^ z;\n    else if (group === 3)\n        return (x & z) | (y & ~z);\n    else\n        return x ^ (y | ~z);\n}\n// Temporary buffer, not used to store anything between runs\nconst BUF = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        BUF.fill(0);\n    }\n    destroy() {\n        this.destroyed = true;\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a hash function from 1990s.\n * @param message - msg that would be hashed\n */\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new RIPEMD160());\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNXO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLDBDQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSxvREFBb0Q7QUFDcEQsc0RBQXNEO0FBQ3RELDREQUE0RDtBQUM1RCw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLDBEQUFlO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzIvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3JpcGVtZDE2MC5qcz9kYzc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuLy8gaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcbmNvbnN0IFJobyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheShbNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOF0pO1xuY29uc3QgSWQgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IC8qIEBfX1BVUkVfXyAqLyBJZC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpO1xubGV0IGlkeEwgPSBbSWRdO1xubGV0IGlkeFIgPSBbUGldO1xuZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgZm9yIChsZXQgaiBvZiBbaWR4TCwgaWR4Ul0pXG4gICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvW2tdKSk7XG5jb25zdCBzaGlmdHMgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IG5ldyBVaW50OEFycmF5KGkpKTtcbmNvbnN0IHNoaWZ0c0wgPSAvKiBAX19QVVJFX18gKi8gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0c1tpXVtqXSkpO1xuY29uc3QgS2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDAwMDAwMDAwLCAweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGE5NTNmZDRlLFxuXSk7XG5jb25zdCBLciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSgxNik7XG5leHBvcnQgY2xhc3MgUklQRU1EMTYwIGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRltpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbFtncm91cF0sIGhiciA9IEtyW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTFtncm91cF0sIHNyID0gc2hpZnRzUltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAocm90bChhbCArIGYoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSAocm90bChhciArIGYockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRltycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBCVUYuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKipcbiAqIFJJUEVNRC0xNjAgLSBhIGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gbXNnIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCByaXBlbWQxNjAgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaXBlbWQxNjAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/MTUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QztBQUNBO0FBQ0Esc0RBQXNELHFEQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMsd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxFQUFFLG1EQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQyxpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QyxtQ0FBbUMsMERBQWU7QUFDbEQsbUNBQW1DLDBEQUFlO0FBQ2xELCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/NWQ0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDMyL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ1Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/MGY0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuLy8gT3RoZXIgbGlicmFyaWVzIHdvdWxkIHNpbGVudGx5IGNvcnJ1cHQgdGhlIGRhdGEgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcixcbi8vIHdoZW4gdGhleSBkb24ndCBzdXBwb3J0IGl0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKCFpc0J5dGVzKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/@scure/bip39/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   entropyToMnemonic: () => (/* binding */ entropyToMnemonic),\n/* harmony export */   generateMnemonic: () => (/* binding */ generateMnemonic),\n/* harmony export */   mnemonicToEntropy: () => (/* binding */ mnemonicToEntropy),\n/* harmony export */   mnemonicToSeed: () => (/* binding */ mnemonicToSeed),\n/* harmony export */   mnemonicToSeedSync: () => (/* binding */ mnemonicToSeedSync),\n/* harmony export */   validateMnemonic: () => (/* binding */ validateMnemonic)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/_assert */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/pbkdf2 */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(rsc)/./node_modules/@scure/base/lib/esm/index.js\");\n\n\n\n\n\n\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction assertEntropy(entropy) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(entropy, 16, 20, 24, 28, 32);\n}\nfunction generateMnemonic(wordlist, strength = 128) {\n    _noble_hashes_assert__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    const bitsLeft = 8 - entropy.length / 4;\n    return new Uint8Array([((0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Worlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error(`Wordlist: non-string element: ${i}`);\n    });\n    return _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.chain(_scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.checksum(1, calcChecksum), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.radix2(11, true), _scure_base__WEBPACK_IMPORTED_MODULE_3__.utils.alphabet(wordlist));\n}\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    assertEntropy(entropy);\n    return entropy;\n}\nfunction entropyToMnemonic(entropy, wordlist) {\n    assertEntropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst salt = (passphrase) => nfkd(`mnemonic${passphrase}`);\nfunction mnemonicToSeed(mnemonic, passphrase = '') {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2Async)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\nfunction mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return (0,_noble_hashes_pbkdf2__WEBPACK_IMPORTED_MODULE_4__.pbkdf2)(_noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_5__.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDZ0I7QUFDYjtBQUNBO0FBQ0k7QUFDRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxrRUFBWTtBQUNoQjtBQUNPO0FBQ1AsSUFBSSxtRUFBYTtBQUNqQjtBQUNBO0FBQ0EsNkJBQTZCLGdFQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsRUFBRTtBQUMvRCxLQUFLO0FBQ0wsV0FBVyw4Q0FBUyxPQUFPLDhDQUFTLDRCQUE0Qiw4Q0FBUyxtQkFBbUIsOENBQVM7QUFDckc7QUFDTztBQUNQLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUNqRDtBQUNQLFdBQVcsaUVBQVcsQ0FBQyx3REFBTSxnREFBZ0Qsb0JBQW9CO0FBQ2pHO0FBQ087QUFDUCxXQUFXLDREQUFNLENBQUMsd0RBQU0sZ0RBQWdELG9CQUFvQjtBQUM1RjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvZXNtL2luZGV4LmpzPzAxYWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdAbm9ibGUvaGFzaGVzL19hc3NlcnQnO1xuaW1wb3J0IHsgcGJrZGYyLCBwYmtkZjJBc3luYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvcGJrZGYyJztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhNTEyJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB1dGlscyBhcyBiYXNlVXRpbHMgfSBmcm9tICdAc2N1cmUvYmFzZSc7XG5jb25zdCBpc0phcGFuZXNlID0gKHdvcmRsaXN0KSA9PiB3b3JkbGlzdFswXSA9PT0gJ1xcdTMwNDJcXHUzMDQ0XFx1MzA1M1xcdTMwNGZcXHUzMDU3XFx1MzA5Myc7XG5mdW5jdGlvbiBuZmtkKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIHN0ci5ub3JtYWxpemUoJ05GS0QnKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzdHIpIHtcbiAgICBjb25zdCBub3JtID0gbmZrZChzdHIpO1xuICAgIGNvbnN0IHdvcmRzID0gbm9ybS5zcGxpdCgnICcpO1xuICAgIGlmICghWzEyLCAxNSwgMTgsIDIxLCAyNF0uaW5jbHVkZXMod29yZHMubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1uZW1vbmljJyk7XG4gICAgcmV0dXJuIHsgbmZrZDogbm9ybSwgd29yZHMgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudHJvcHkoZW50cm9weSkge1xuICAgIGFzc2VydC5ieXRlcyhlbnRyb3B5LCAxNiwgMjAsIDI0LCAyOCwgMzIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTW5lbW9uaWMod29yZGxpc3QsIHN0cmVuZ3RoID0gMTI4KSB7XG4gICAgYXNzZXJ0Lm51bWJlcihzdHJlbmd0aCk7XG4gICAgaWYgKHN0cmVuZ3RoICUgMzIgIT09IDAgfHwgc3RyZW5ndGggPiAyNTYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZW50cm9weScpO1xuICAgIHJldHVybiBlbnRyb3B5VG9NbmVtb25pYyhyYW5kb21CeXRlcyhzdHJlbmd0aCAvIDgpLCB3b3JkbGlzdCk7XG59XG5jb25zdCBjYWxjQ2hlY2tzdW0gPSAoZW50cm9weSkgPT4ge1xuICAgIGNvbnN0IGJpdHNMZWZ0ID0gOCAtIGVudHJvcHkubGVuZ3RoIC8gNDtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWyhzaGEyNTYoZW50cm9weSlbMF0gPj4gYml0c0xlZnQpIDw8IGJpdHNMZWZ0XSk7XG59O1xuZnVuY3Rpb24gZ2V0Q29kZXIod29yZGxpc3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZGxpc3QpIHx8IHdvcmRsaXN0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2Ygd29yZGxpc3RbMF0gIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmxpc3Q6IGV4cGVjdGVkIGFycmF5IG9mIDIwNDggc3RyaW5ncycpO1xuICAgIHdvcmRsaXN0LmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV29yZGxpc3Q6IG5vbi1zdHJpbmcgZWxlbWVudDogJHtpfWApO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlVXRpbHMuY2hhaW4oYmFzZVV0aWxzLmNoZWNrc3VtKDEsIGNhbGNDaGVja3N1bSksIGJhc2VVdGlscy5yYWRpeDIoMTEsIHRydWUpLCBiYXNlVXRpbHMuYWxwaGFiZXQod29yZGxpc3QpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBub3JtYWxpemUobW5lbW9uaWMpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBnZXRDb2Rlcih3b3JkbGlzdCkuZGVjb2RlKHdvcmRzKTtcbiAgICBhc3NlcnRFbnRyb3B5KGVudHJvcHkpO1xuICAgIHJldHVybiBlbnRyb3B5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG4gICAgYXNzZXJ0RW50cm9weShlbnRyb3B5KTtcbiAgICBjb25zdCB3b3JkcyA9IGdldENvZGVyKHdvcmRsaXN0KS5lbmNvZGUoZW50cm9weSk7XG4gICAgcmV0dXJuIHdvcmRzLmpvaW4oaXNKYXBhbmVzZSh3b3JkbGlzdCkgPyAnXFx1MzAwMCcgOiAnICcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IHNhbHQgPSAocGFzc3BocmFzZSkgPT4gbmZrZChgbW5lbW9uaWMke3Bhc3NwaHJhc2V9YCk7XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3NwaHJhc2UgPSAnJykge1xuICAgIHJldHVybiBwYmtkZjJBc3luYyhzaGE1MTIsIG5vcm1hbGl6ZShtbmVtb25pYykubmZrZCwgc2FsdChwYXNzcGhyYXNlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzcGhyYXNlID0gJycpIHtcbiAgICByZXR1cm4gcGJrZGYyKHNoYTUxMiwgbm9ybWFsaXplKG1uZW1vbmljKS5uZmtkLCBzYWx0KHBhc3NwaHJhc2UpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanM/ZjY2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/MTk0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUw7QUFDakw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsR0FBRyxFQUFDO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/M2ExMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQzNCLGVBQWUsMk1BQUUsV0FBVywyTUFBRSxpQkFBaUIsME5BQWlCLEdBQUcsa0RBQVk7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz84YWRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW1iZWRkZWQtYWNjb3VudHMtcXVpY2tzdGFydC8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmlwMzkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/ZmViYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.hash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(c);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(dkLen);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.number)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\n/**\n * PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n */\nfunction pbkdf2(hash, password, salt, opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 + ⋯ + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, () => {\n            // Uc = PRF(Password, Uc−1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n//# sourceMappingURL=pbkdf2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9wYmtkZjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEU7QUFDekM7QUFDc0M7QUFDdkU7QUFDQTtBQUNBLElBQUksZ0RBQVU7QUFDZCxpQkFBaUIsb0RBQVMsR0FBRywwQkFBMEI7QUFDdkQsWUFBWSxzQkFBc0I7QUFDbEMsSUFBSSxrREFBWTtBQUNoQixJQUFJLGtEQUFZO0FBQ2hCLElBQUksa0RBQVk7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQixrREFBTztBQUM1QixpQkFBaUIsa0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUFJO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNPO0FBQ1AsWUFBWSw2QkFBNkI7QUFDekMsY0FBYztBQUNkO0FBQ0EsaUJBQWlCLHFEQUFVO0FBQzNCO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdDQUF3QztBQUNwRCxjQUFjO0FBQ2Q7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBUztBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vcGJrZGYyLmpzP2RmYWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBudW1iZXIgYXMgYXNzZXJ0TnVtYmVyIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IGhtYWMgfSBmcm9tICcuL2htYWMuanMnO1xuaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgY2hlY2tPcHRzLCBhc3luY0xvb3AgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIENvbW1vbiBwcm9sb2d1ZSBhbmQgZXBpbG9ndWUgZm9yIHN5bmMvYXN5bmMgZnVuY3Rpb25zXG5mdW5jdGlvbiBwYmtkZjJJbml0KGhhc2gsIF9wYXNzd29yZCwgX3NhbHQsIF9vcHRzKSB7XG4gICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICBjb25zdCBvcHRzID0gY2hlY2tPcHRzKHsgZGtMZW46IDMyLCBhc3luY1RpY2s6IDEwIH0sIF9vcHRzKTtcbiAgICBjb25zdCB7IGMsIGRrTGVuLCBhc3luY1RpY2sgfSA9IG9wdHM7XG4gICAgYXNzZXJ0TnVtYmVyKGMpO1xuICAgIGFzc2VydE51bWJlcihka0xlbik7XG4gICAgYXNzZXJ0TnVtYmVyKGFzeW5jVGljayk7XG4gICAgaWYgKGMgPCAxKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BCS0RGMjogaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDEnKTtcbiAgICBjb25zdCBwYXNzd29yZCA9IHRvQnl0ZXMoX3Bhc3N3b3JkKTtcbiAgICBjb25zdCBzYWx0ID0gdG9CeXRlcyhfc2FsdCk7XG4gICAgLy8gREsgPSBQQktERjIoUFJGLCBQYXNzd29yZCwgU2FsdCwgYywgZGtMZW4pO1xuICAgIGNvbnN0IERLID0gbmV3IFVpbnQ4QXJyYXkoZGtMZW4pO1xuICAgIC8vIFUxID0gUFJGKFBhc3N3b3JkLCBTYWx0ICsgSU5UXzMyX0JFKGkpKVxuICAgIGNvbnN0IFBSRiA9IGhtYWMuY3JlYXRlKGhhc2gsIHBhc3N3b3JkKTtcbiAgICBjb25zdCBQUkZTYWx0ID0gUFJGLl9jbG9uZUludG8oKS51cGRhdGUoc2FsdCk7XG4gICAgcmV0dXJuIHsgYywgZGtMZW4sIGFzeW5jVGljaywgREssIFBSRiwgUFJGU2FsdCB9O1xufVxuZnVuY3Rpb24gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpIHtcbiAgICBQUkYuZGVzdHJveSgpO1xuICAgIFBSRlNhbHQuZGVzdHJveSgpO1xuICAgIGlmIChwcmZXKVxuICAgICAgICBwcmZXLmRlc3Ryb3koKTtcbiAgICB1LmZpbGwoMCk7XG4gICAgcmV0dXJuIERLO1xufVxuLyoqXG4gKiBQQktERjItSE1BQzogUkZDIDI4OTgga2V5IGRlcml2YXRpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBwYXNzd29yZCAtIHBhc3N3b3JkIGZyb20gd2hpY2ggYSBkZXJpdmVkIGtleSBpcyBnZW5lcmF0ZWRcbiAqIEBwYXJhbSBzYWx0IC0gY3J5cHRvZ3JhcGhpYyBzYWx0XG4gKiBAcGFyYW0gb3B0cyAtIHtjLCBka0xlbn0gd2hlcmUgYyBpcyB3b3JrIGZhY3RvciBhbmQgZGtMZW4gaXMgb3V0cHV0IG1lc3NhZ2Ugc2l6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGJrZGYyKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgREssIFBSRiwgUFJGU2FsdCB9ID0gcGJrZGYySW5pdChoYXNoLCBwYXNzd29yZCwgc2FsdCwgb3B0cyk7XG4gICAgbGV0IHByZlc7IC8vIFdvcmtpbmcgY29weVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGFycik7XG4gICAgY29uc3QgdSA9IG5ldyBVaW50OEFycmF5KFBSRi5vdXRwdXRMZW4pO1xuICAgIC8vIERLID0gVDEgKyBUMiArIOKLryArIFRka2xlbi9obGVuXG4gICAgZm9yIChsZXQgdGkgPSAxLCBwb3MgPSAwOyBwb3MgPCBka0xlbjsgdGkrKywgcG9zICs9IFBSRi5vdXRwdXRMZW4pIHtcbiAgICAgICAgLy8gVGkgPSBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKVxuICAgICAgICBjb25zdCBUaSA9IERLLnN1YmFycmF5KHBvcywgcG9zICsgUFJGLm91dHB1dExlbik7XG4gICAgICAgIHZpZXcuc2V0SW50MzIoMCwgdGksIGZhbHNlKTtcbiAgICAgICAgLy8gRihQYXNzd29yZCwgU2FsdCwgYywgaSkgPSBVMSBeIFUyIF4g4ouvIF4gVWNcbiAgICAgICAgLy8gVTEgPSBQUkYoUGFzc3dvcmQsIFNhbHQgKyBJTlRfMzJfQkUoaSkpXG4gICAgICAgIChwcmZXID0gUFJGU2FsdC5fY2xvbmVJbnRvKHByZlcpKS51cGRhdGUoYXJyKS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICBUaS5zZXQodS5zdWJhcnJheSgwLCBUaS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChsZXQgdWkgPSAxOyB1aSA8IGM7IHVpKyspIHtcbiAgICAgICAgICAgIC8vIFVjID0gUFJGKFBhc3N3b3JkLCBVY+KIkjEpXG4gICAgICAgICAgICBQUkYuX2Nsb25lSW50byhwcmZXKS51cGRhdGUodSkuZGlnZXN0SW50byh1KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgVGkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgVGlbaV0gXj0gdVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGJrZGYyT3V0cHV0KFBSRiwgUFJGU2FsdCwgREssIHByZlcsIHUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBia2RmMkFzeW5jKGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKSB7XG4gICAgY29uc3QgeyBjLCBka0xlbiwgYXN5bmNUaWNrLCBESywgUFJGLCBQUkZTYWx0IH0gPSBwYmtkZjJJbml0KGhhc2gsIHBhc3N3b3JkLCBzYWx0LCBvcHRzKTtcbiAgICBsZXQgcHJmVzsgLy8gV29ya2luZyBjb3B5XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcoYXJyKTtcbiAgICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoUFJGLm91dHB1dExlbik7XG4gICAgLy8gREsgPSBUMSArIFQyICsg4ouvICsgVGRrbGVuL2hsZW5cbiAgICBmb3IgKGxldCB0aSA9IDEsIHBvcyA9IDA7IHBvcyA8IGRrTGVuOyB0aSsrLCBwb3MgKz0gUFJGLm91dHB1dExlbikge1xuICAgICAgICAvLyBUaSA9IEYoUGFzc3dvcmQsIFNhbHQsIGMsIGkpXG4gICAgICAgIGNvbnN0IFRpID0gREsuc3ViYXJyYXkocG9zLCBwb3MgKyBQUkYub3V0cHV0TGVuKTtcbiAgICAgICAgdmlldy5zZXRJbnQzMigwLCB0aSwgZmFsc2UpO1xuICAgICAgICAvLyBGKFBhc3N3b3JkLCBTYWx0LCBjLCBpKSA9IFUxIF4gVTIgXiDii68gXiBVY1xuICAgICAgICAvLyBVMSA9IFBSRihQYXNzd29yZCwgU2FsdCArIElOVF8zMl9CRShpKSlcbiAgICAgICAgKHByZlcgPSBQUkZTYWx0Ll9jbG9uZUludG8ocHJmVykpLnVwZGF0ZShhcnIpLmRpZ2VzdEludG8odSk7XG4gICAgICAgIFRpLnNldCh1LnN1YmFycmF5KDAsIFRpLmxlbmd0aCkpO1xuICAgICAgICBhd2FpdCBhc3luY0xvb3AoYyAtIDEsIGFzeW5jVGljaywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gVWMgPSBQUkYoUGFzc3dvcmQsIFVj4oiSMSlcbiAgICAgICAgICAgIFBSRi5fY2xvbmVJbnRvKHByZlcpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKHUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBUaS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBUaVtpXSBePSB1W2ldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBia2RmMk91dHB1dChQUkYsIFBSRlNhbHQsIERLLCBwcmZXLCB1KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBia2RmMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/YWRiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_sha2.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_1__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QztBQUNBO0FBQ0Esc0RBQXNELHFEQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMsd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxFQUFFLG1EQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQyxpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QyxtQ0FBbUMsMERBQWU7QUFDbEQsbUNBQW1DLDBEQUFlO0FBQ2xELCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VtYmVkZGVkLWFjY291bnRzLXF1aWNrc3RhcnQvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanM/MTMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFJvdW5kIGNvbnRhbnRzIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgW1NIQTUxMl9LaCwgU0hBNTEyX0tsXSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!isBytes(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!isBytes(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        if (!isBytes(a))\n            throw new Error('Uint8Array expected');\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNjdXJlL2JpcDM5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ1Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbWJlZGRlZC1hY2NvdW50cy1xdWlja3N0YXJ0Ly4vbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzOS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/OWExOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuLy8gT3RoZXIgbGlicmFyaWVzIHdvdWxkIHNpbGVudGx5IGNvcnJ1cHQgdGhlIGRhdGEgaW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvcixcbi8vIHdoZW4gdGhleSBkb24ndCBzdXBwb3J0IGl0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIWlzQnl0ZXMoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgaWYgKCFpc0J5dGVzKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;